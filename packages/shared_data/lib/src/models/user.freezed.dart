// dart format width=80
// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'user.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

// dart format off
T _$identity<T>(T value) => value;
BaseUser _$BaseUserFromJson(Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'auth':
      return AuthUser.fromJson(json);
    case 'socialUser':
      return SocialUser.fromJson(json);

    default:
      throw CheckedFromJsonException(json, 'runtimeType', 'BaseUser',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$BaseUser {
  /// Unique identifier. Generated by Firestore as the primary Uid and used
  /// for any relations.
  String get id;

  /// User's email address. Null for anonymous users and possibly some social
  /// auth situations.
  String? get email;

  /// Origin timestamp of the user.
  DateTime get createdAt;

  /// Create a copy of BaseUser
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $BaseUserCopyWith<BaseUser> get copyWith =>
      _$BaseUserCopyWithImpl<BaseUser>(this as BaseUser, _$identity);

  /// Serializes this BaseUser to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is BaseUser &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.email, email) || other.email == email) &&
            (identical(other.createdAt, createdAt) ||
                other.createdAt == createdAt));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, id, email, createdAt);

  @override
  String toString() {
    return 'BaseUser(id: $id, email: $email, createdAt: $createdAt)';
  }
}

/// @nodoc
abstract mixin class $BaseUserCopyWith<$Res> {
  factory $BaseUserCopyWith(BaseUser value, $Res Function(BaseUser) _then) =
      _$BaseUserCopyWithImpl;
  @useResult
  $Res call({String id, String? email, DateTime createdAt});
}

/// @nodoc
class _$BaseUserCopyWithImpl<$Res> implements $BaseUserCopyWith<$Res> {
  _$BaseUserCopyWithImpl(this._self, this._then);

  final BaseUser _self;
  final $Res Function(BaseUser) _then;

  /// Create a copy of BaseUser
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? email = freezed,
    Object? createdAt = null,
  }) {
    return _then(_self.copyWith(
      id: null == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      email: freezed == email
          ? _self.email
          : email // ignore: cast_nullable_to_non_nullable
              as String?,
      createdAt: null == createdAt
          ? _self.createdAt
          : createdAt // ignore: cast_nullable_to_non_nullable
              as DateTime,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class AuthUser extends BaseUser {
  const AuthUser(
      {required this.id,
      this.jwt,
      required this.loggingId,
      this.email,
      required this.createdAt,
      required this.lastAuthProvider,
      required final Set<AuthProvider> allProviders,
      final String? $type})
      : _allProviders = allProviders,
        $type = $type ?? 'auth',
        super._();
  factory AuthUser.fromJson(Map<String, dynamic> json) =>
      _$AuthUserFromJson(json);

  /// Unique identifier. Generated by Firestore as the primary Uid and used
  /// for any relations.
  @override
  final String id;

  /// Special information set by the server and used to verify this session
  /// between multiple backends.
  final String? jwt;

  /// Unique identifier prepended to all logging statements for this user.
  /// Not sensitive.
  final String loggingId;

  /// User's email address. Null for anonymous users and possibly some social
  /// auth situations.
  @override
  final String? email;

  /// Origin timestamp of the user.
  @override
  final DateTime createdAt;

  /// Last verifying auth provider for this user.
  final AuthProvider lastAuthProvider;

  /// All providers ever activated for this user.
  final Set<AuthProvider> _allProviders;

  /// All providers ever activated for this user.
  Set<AuthProvider> get allProviders {
    if (_allProviders is EqualUnmodifiableSetView) return _allProviders;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableSetView(_allProviders);
  }

  @JsonKey(name: 'runtimeType')
  final String $type;

  /// Create a copy of BaseUser
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $AuthUserCopyWith<AuthUser> get copyWith =>
      _$AuthUserCopyWithImpl<AuthUser>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$AuthUserToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is AuthUser &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.jwt, jwt) || other.jwt == jwt) &&
            (identical(other.loggingId, loggingId) ||
                other.loggingId == loggingId) &&
            (identical(other.email, email) || other.email == email) &&
            (identical(other.createdAt, createdAt) ||
                other.createdAt == createdAt) &&
            (identical(other.lastAuthProvider, lastAuthProvider) ||
                other.lastAuthProvider == lastAuthProvider) &&
            const DeepCollectionEquality()
                .equals(other._allProviders, _allProviders));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      jwt,
      loggingId,
      email,
      createdAt,
      lastAuthProvider,
      const DeepCollectionEquality().hash(_allProviders));

  @override
  String toString() {
    return 'BaseUser.auth(id: $id, jwt: $jwt, loggingId: $loggingId, email: $email, createdAt: $createdAt, lastAuthProvider: $lastAuthProvider, allProviders: $allProviders)';
  }
}

/// @nodoc
abstract mixin class $AuthUserCopyWith<$Res>
    implements $BaseUserCopyWith<$Res> {
  factory $AuthUserCopyWith(AuthUser value, $Res Function(AuthUser) _then) =
      _$AuthUserCopyWithImpl;
  @override
  @useResult
  $Res call(
      {String id,
      String? jwt,
      String loggingId,
      String? email,
      DateTime createdAt,
      AuthProvider lastAuthProvider,
      Set<AuthProvider> allProviders});
}

/// @nodoc
class _$AuthUserCopyWithImpl<$Res> implements $AuthUserCopyWith<$Res> {
  _$AuthUserCopyWithImpl(this._self, this._then);

  final AuthUser _self;
  final $Res Function(AuthUser) _then;

  /// Create a copy of BaseUser
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? id = null,
    Object? jwt = freezed,
    Object? loggingId = null,
    Object? email = freezed,
    Object? createdAt = null,
    Object? lastAuthProvider = null,
    Object? allProviders = null,
  }) {
    return _then(AuthUser(
      id: null == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      jwt: freezed == jwt
          ? _self.jwt
          : jwt // ignore: cast_nullable_to_non_nullable
              as String?,
      loggingId: null == loggingId
          ? _self.loggingId
          : loggingId // ignore: cast_nullable_to_non_nullable
              as String,
      email: freezed == email
          ? _self.email
          : email // ignore: cast_nullable_to_non_nullable
              as String?,
      createdAt: null == createdAt
          ? _self.createdAt
          : createdAt // ignore: cast_nullable_to_non_nullable
              as DateTime,
      lastAuthProvider: null == lastAuthProvider
          ? _self.lastAuthProvider
          : lastAuthProvider // ignore: cast_nullable_to_non_nullable
              as AuthProvider,
      allProviders: null == allProviders
          ? _self._allProviders
          : allProviders // ignore: cast_nullable_to_non_nullable
              as Set<AuthProvider>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class SocialUser extends BaseUser {
  const SocialUser(
      {required this.id,
      this.email,
      this.provider,
      required this.createdAt,
      final String? $type})
      : $type = $type ?? 'socialUser',
        super._();
  factory SocialUser.fromJson(Map<String, dynamic> json) =>
      _$SocialUserFromJson(json);

  /// Unique identifier. Generated by the social auth provider..
  @override
  final String id;

  /// User's email address. Null for anonymous users and possibly some social
  /// auth situations.
  @override
  final String? email;

  /// Auth method used to create this new account. This value is known when
  /// the user is created, but not necessarily known when the user is later
  /// emitted from the stream.
  final AuthProvider? provider;

  /// Origin timestamp of this user.
  @override
  final DateTime createdAt;

  @JsonKey(name: 'runtimeType')
  final String $type;

  /// Create a copy of BaseUser
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $SocialUserCopyWith<SocialUser> get copyWith =>
      _$SocialUserCopyWithImpl<SocialUser>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$SocialUserToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is SocialUser &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.email, email) || other.email == email) &&
            (identical(other.provider, provider) ||
                other.provider == provider) &&
            (identical(other.createdAt, createdAt) ||
                other.createdAt == createdAt));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, id, email, provider, createdAt);

  @override
  String toString() {
    return 'BaseUser.socialUser(id: $id, email: $email, provider: $provider, createdAt: $createdAt)';
  }
}

/// @nodoc
abstract mixin class $SocialUserCopyWith<$Res>
    implements $BaseUserCopyWith<$Res> {
  factory $SocialUserCopyWith(
          SocialUser value, $Res Function(SocialUser) _then) =
      _$SocialUserCopyWithImpl;
  @override
  @useResult
  $Res call(
      {String id, String? email, AuthProvider? provider, DateTime createdAt});
}

/// @nodoc
class _$SocialUserCopyWithImpl<$Res> implements $SocialUserCopyWith<$Res> {
  _$SocialUserCopyWithImpl(this._self, this._then);

  final SocialUser _self;
  final $Res Function(SocialUser) _then;

  /// Create a copy of BaseUser
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? id = null,
    Object? email = freezed,
    Object? provider = freezed,
    Object? createdAt = null,
  }) {
    return _then(SocialUser(
      id: null == id
          ? _self.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      email: freezed == email
          ? _self.email
          : email // ignore: cast_nullable_to_non_nullable
              as String?,
      provider: freezed == provider
          ? _self.provider
          : provider // ignore: cast_nullable_to_non_nullable
              as AuthProvider?,
      createdAt: null == createdAt
          ? _self.createdAt
          : createdAt // ignore: cast_nullable_to_non_nullable
              as DateTime,
    ));
  }
}

SocialCredential _$SocialCredentialFromJson(Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'email':
      return EmailCredential.fromJson(json);
    case 'apple':
      return AppleCredential.fromJson(json);
    case 'google':
      return GoogleCredential.fromJson(json);

    default:
      throw CheckedFromJsonException(json, 'runtimeType', 'SocialCredential',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$SocialCredential {
  /// Email used to sign in.
  String? get email;

  /// Create a copy of SocialCredential
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $SocialCredentialCopyWith<SocialCredential> get copyWith =>
      _$SocialCredentialCopyWithImpl<SocialCredential>(
          this as SocialCredential, _$identity);

  /// Serializes this SocialCredential to a JSON map.
  Map<String, dynamic> toJson();

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is SocialCredential &&
            (identical(other.email, email) || other.email == email));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, email);

  @override
  String toString() {
    return 'SocialCredential(email: $email)';
  }
}

/// @nodoc
abstract mixin class $SocialCredentialCopyWith<$Res> {
  factory $SocialCredentialCopyWith(
          SocialCredential value, $Res Function(SocialCredential) _then) =
      _$SocialCredentialCopyWithImpl;
  @useResult
  $Res call({String email});
}

/// @nodoc
class _$SocialCredentialCopyWithImpl<$Res>
    implements $SocialCredentialCopyWith<$Res> {
  _$SocialCredentialCopyWithImpl(this._self, this._then);

  final SocialCredential _self;
  final $Res Function(SocialCredential) _then;

  /// Create a copy of SocialCredential
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? email = null,
  }) {
    return _then(_self.copyWith(
      email: null == email
          ? _self.email!
          : email // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class EmailCredential extends SocialCredential {
  const EmailCredential(
      {required this.email, required this.password, final String? $type})
      : $type = $type ?? 'email',
        super._();
  factory EmailCredential.fromJson(Map<String, dynamic> json) =>
      _$EmailCredentialFromJson(json);

  /// Email used to sign in.
  @override
  final String email;

  /// Password used to sign in. Required to propagate email sign-ins between
  /// auth services. Should never be stored on the client or in plain text on
  /// the server.
  final String password;

  @JsonKey(name: 'runtimeType')
  final String $type;

  /// Create a copy of SocialCredential
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $EmailCredentialCopyWith<EmailCredential> get copyWith =>
      _$EmailCredentialCopyWithImpl<EmailCredential>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$EmailCredentialToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is EmailCredential &&
            (identical(other.email, email) || other.email == email) &&
            (identical(other.password, password) ||
                other.password == password));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, email, password);

  @override
  String toString() {
    return 'SocialCredential.email(email: $email, password: $password)';
  }
}

/// @nodoc
abstract mixin class $EmailCredentialCopyWith<$Res>
    implements $SocialCredentialCopyWith<$Res> {
  factory $EmailCredentialCopyWith(
          EmailCredential value, $Res Function(EmailCredential) _then) =
      _$EmailCredentialCopyWithImpl;
  @override
  @useResult
  $Res call({String email, String password});
}

/// @nodoc
class _$EmailCredentialCopyWithImpl<$Res>
    implements $EmailCredentialCopyWith<$Res> {
  _$EmailCredentialCopyWithImpl(this._self, this._then);

  final EmailCredential _self;
  final $Res Function(EmailCredential) _then;

  /// Create a copy of SocialCredential
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? email = null,
    Object? password = null,
  }) {
    return _then(EmailCredential(
      email: null == email
          ? _self.email
          : email // ignore: cast_nullable_to_non_nullable
              as String,
      password: null == password
          ? _self.password
          : password // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class AppleCredential extends SocialCredential {
  const AppleCredential(
      {required this.userIdentifier,
      required this.givenName,
      required this.familyName,
      required this.email,
      required this.authorizationCode,
      required this.identityToken,
      required this.state,
      final String? $type})
      : $type = $type ?? 'apple',
        super._();
  factory AppleCredential.fromJson(Map<String, dynamic> json) =>
      _$AppleCredentialFromJson(json);

  /// An identifier associated with the authenticated user.
  ///
  /// This will always be provided on iOS and macOS systems. On Android,
  /// however, this will not be present.
  /// This will stay the same between sign ins, until the user deauthorizes
  /// your App.
  ///
  /// Not-null in our implementation because Apple Sign-In is not offered on
  /// Android.
  final String? userIdentifier;

  /// The users given name, in case it was requested.
  /// You will need to provide the [AppleIDAuthorizationScopes.fullName] scope
  /// to the [AppleIDAuthorizationRequest] for requesting this information.
  ///
  /// This information will only be provided on the first authorizations.
  /// Upon further authorizations, you will only get the [userIdentifier],
  /// meaning you will need to store this data securely on your servers.
  /// For more information see:
  /// https://forums.developer.apple.com/thread/121496
  final String? givenName;

  /// The users family name, in case it was requested.
  /// You will need to provide the [AppleIDAuthorizationScopes.fullName] scope
  /// to the [AppleIDAuthorizationRequest] for requesting this information.
  ///
  /// This information will only be provided on the first authorizations.
  /// Upon further authorizations, you will only get the [userIdentifier],
  /// meaning you will need to store this data securely on your servers.
  /// For more information see:
  /// https://forums.developer.apple.com/thread/121496
  final String? familyName;

  /// The users email in case it was requested.
  /// You will need to provide the [AppleIDAuthorizationScopes.email] scope to
  /// the [AppleIDAuthorizationRequest] for requesting this information.
  ///
  /// This information will only be provided on the first authorizations.
  /// Upon further authorizations, you will only get the [userIdentifier],
  /// meaning you will need to store this data securely on your servers.
  /// For more information see:
  /// https://forums.developer.apple.com/thread/121496
  @override
  final String? email;

  /// The verification code for the current authorization.
  ///
  /// This code should be used by your server component to validate the
  /// authorization with Apple within 5 minutes upon receiving it.
  final String authorizationCode;

  /// A JSON Web Token (JWT) that securely communicates information about the
  /// user to your app.
  final String? identityToken;

  /// The `state` parameter that was passed to the request.
  ///
  /// This data is not modified by Apple.
  final String? state;

  @JsonKey(name: 'runtimeType')
  final String $type;

  /// Create a copy of SocialCredential
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $AppleCredentialCopyWith<AppleCredential> get copyWith =>
      _$AppleCredentialCopyWithImpl<AppleCredential>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$AppleCredentialToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is AppleCredential &&
            (identical(other.userIdentifier, userIdentifier) ||
                other.userIdentifier == userIdentifier) &&
            (identical(other.givenName, givenName) ||
                other.givenName == givenName) &&
            (identical(other.familyName, familyName) ||
                other.familyName == familyName) &&
            (identical(other.email, email) || other.email == email) &&
            (identical(other.authorizationCode, authorizationCode) ||
                other.authorizationCode == authorizationCode) &&
            (identical(other.identityToken, identityToken) ||
                other.identityToken == identityToken) &&
            (identical(other.state, state) || other.state == state));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, userIdentifier, givenName,
      familyName, email, authorizationCode, identityToken, state);

  @override
  String toString() {
    return 'SocialCredential.apple(userIdentifier: $userIdentifier, givenName: $givenName, familyName: $familyName, email: $email, authorizationCode: $authorizationCode, identityToken: $identityToken, state: $state)';
  }
}

/// @nodoc
abstract mixin class $AppleCredentialCopyWith<$Res>
    implements $SocialCredentialCopyWith<$Res> {
  factory $AppleCredentialCopyWith(
          AppleCredential value, $Res Function(AppleCredential) _then) =
      _$AppleCredentialCopyWithImpl;
  @override
  @useResult
  $Res call(
      {String? userIdentifier,
      String? givenName,
      String? familyName,
      String? email,
      String authorizationCode,
      String? identityToken,
      String? state});
}

/// @nodoc
class _$AppleCredentialCopyWithImpl<$Res>
    implements $AppleCredentialCopyWith<$Res> {
  _$AppleCredentialCopyWithImpl(this._self, this._then);

  final AppleCredential _self;
  final $Res Function(AppleCredential) _then;

  /// Create a copy of SocialCredential
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? userIdentifier = freezed,
    Object? givenName = freezed,
    Object? familyName = freezed,
    Object? email = freezed,
    Object? authorizationCode = null,
    Object? identityToken = freezed,
    Object? state = freezed,
  }) {
    return _then(AppleCredential(
      userIdentifier: freezed == userIdentifier
          ? _self.userIdentifier
          : userIdentifier // ignore: cast_nullable_to_non_nullable
              as String?,
      givenName: freezed == givenName
          ? _self.givenName
          : givenName // ignore: cast_nullable_to_non_nullable
              as String?,
      familyName: freezed == familyName
          ? _self.familyName
          : familyName // ignore: cast_nullable_to_non_nullable
              as String?,
      email: freezed == email
          ? _self.email
          : email // ignore: cast_nullable_to_non_nullable
              as String?,
      authorizationCode: null == authorizationCode
          ? _self.authorizationCode
          : authorizationCode // ignore: cast_nullable_to_non_nullable
              as String,
      identityToken: freezed == identityToken
          ? _self.identityToken
          : identityToken // ignore: cast_nullable_to_non_nullable
              as String?,
      state: freezed == state
          ? _self.state
          : state // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class GoogleCredential extends SocialCredential {
  const GoogleCredential(
      {required this.displayName,
      required this.email,
      required this.uniqueId,
      required this.photoUrl,
      required this.idToken,
      required this.serverAuthCode,
      final String? $type})
      : $type = $type ?? 'google',
        super._();
  factory GoogleCredential.fromJson(Map<String, dynamic> json) =>
      _$GoogleCredentialFromJson(json);

  /// The display name of the signed in user.
  ///
  /// Not guaranteed to be present for all users, even when configured.
  final String? displayName;

  /// The email address of the signed in user.
  ///
  /// Applications should not key users by email address since a Google
  /// account's email address can change. Use [id] as a key instead.
  ///
  /// _Important_: Do not use this returned email address to communicate the
  /// currently signed in user to your backend server. Instead, send an ID
  /// token which can be securely validated on the server. See [idToken].
  @override
  final String email;

  /// The unique ID for the Google account. Called [id] in the package.
  ///
  /// This is the preferred unique key to use for a user record.
  ///
  /// _Important_: Do not use this returned Google ID to communicate the
  /// currently signed in user to your backend server. Instead, send an ID
  /// token which can be securely validated on the server. See [idToken].
  final String uniqueId;

  /// The photo url of the signed in user if the user has a profile picture.
  ///
  /// Not guaranteed to be present for all users, even when configured.
  final String? photoUrl;

  /// A token that can be sent to your own server to verify the authentication
  /// data.
  final String? idToken;

  /// Server auth code used to access Google Login
  final String? serverAuthCode;

  @JsonKey(name: 'runtimeType')
  final String $type;

  /// Create a copy of SocialCredential
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  @pragma('vm:prefer-inline')
  $GoogleCredentialCopyWith<GoogleCredential> get copyWith =>
      _$GoogleCredentialCopyWithImpl<GoogleCredential>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$GoogleCredentialToJson(
      this,
    );
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is GoogleCredential &&
            (identical(other.displayName, displayName) ||
                other.displayName == displayName) &&
            (identical(other.email, email) || other.email == email) &&
            (identical(other.uniqueId, uniqueId) ||
                other.uniqueId == uniqueId) &&
            (identical(other.photoUrl, photoUrl) ||
                other.photoUrl == photoUrl) &&
            (identical(other.idToken, idToken) || other.idToken == idToken) &&
            (identical(other.serverAuthCode, serverAuthCode) ||
                other.serverAuthCode == serverAuthCode));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, displayName, email, uniqueId,
      photoUrl, idToken, serverAuthCode);

  @override
  String toString() {
    return 'SocialCredential.google(displayName: $displayName, email: $email, uniqueId: $uniqueId, photoUrl: $photoUrl, idToken: $idToken, serverAuthCode: $serverAuthCode)';
  }
}

/// @nodoc
abstract mixin class $GoogleCredentialCopyWith<$Res>
    implements $SocialCredentialCopyWith<$Res> {
  factory $GoogleCredentialCopyWith(
          GoogleCredential value, $Res Function(GoogleCredential) _then) =
      _$GoogleCredentialCopyWithImpl;
  @override
  @useResult
  $Res call(
      {String? displayName,
      String email,
      String uniqueId,
      String? photoUrl,
      String? idToken,
      String? serverAuthCode});
}

/// @nodoc
class _$GoogleCredentialCopyWithImpl<$Res>
    implements $GoogleCredentialCopyWith<$Res> {
  _$GoogleCredentialCopyWithImpl(this._self, this._then);

  final GoogleCredential _self;
  final $Res Function(GoogleCredential) _then;

  /// Create a copy of SocialCredential
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $Res call({
    Object? displayName = freezed,
    Object? email = null,
    Object? uniqueId = null,
    Object? photoUrl = freezed,
    Object? idToken = freezed,
    Object? serverAuthCode = freezed,
  }) {
    return _then(GoogleCredential(
      displayName: freezed == displayName
          ? _self.displayName
          : displayName // ignore: cast_nullable_to_non_nullable
              as String?,
      email: null == email
          ? _self.email
          : email // ignore: cast_nullable_to_non_nullable
              as String,
      uniqueId: null == uniqueId
          ? _self.uniqueId
          : uniqueId // ignore: cast_nullable_to_non_nullable
              as String,
      photoUrl: freezed == photoUrl
          ? _self.photoUrl
          : photoUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      idToken: freezed == idToken
          ? _self.idToken
          : idToken // ignore: cast_nullable_to_non_nullable
              as String?,
      serverAuthCode: freezed == serverAuthCode
          ? _self.serverAuthCode
          : serverAuthCode // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

// dart format on
